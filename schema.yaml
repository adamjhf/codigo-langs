type: object
additionalProperties: false
description: Schema for describing programming language characteristics and capabilities

definitions:
  rating_scale:
    type: string
    enum:
      - very low
      - low
      - moderate
      - high
      - very high
  speed_scale:
    type: string
    enum:
      - very fast
      - fast
      - moderate
      - slow
      - very slow
  size_scale:
    type: string
    enum:
      - very large
      - large
      - medium
      - small
      - very small

required:
  - name
  - category

properties:
  name:
    type: string
    description: Official and primary English name of the language

  description:
    type: string
    description: Key summary about the language, in up to 3 sentences

  aliases:
    type: array
    description: Aliases or alternative names used for the language
    items:
      type: string

  file_extensions:
    type: array
    description: File extensions typically used for the language (exclude leading period)
    items:
      type: string

  category:
    type: string
    description: The category or type of the language based on its primary use or classification
    enum:
      - programming
      - markup
      - query
      - assembly
      - stylesheet
      - configuration
      - DSL
      - other

  status:
    type: string
    description: Current development status of the language
    enum:
      - active
      - maintenance
      - legacy
      - experimental
      - deprecated


  compilers:
    type: array
    description: Information about available compilers or interpreters
    items:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          description: Name of the compiler/interpreter
        type:
          type: string
          description: Whether this is a compiler or interpreter
          enum:
            - compiler
            - interpreter
            - hybrid
        license:
          type: string
          description: License under which the compiler/interpreter is released
          enum:
            - MIT
            - Apache-2.0
            - GPL-1.0
            - GPL-2.0
            - GPL-3.0
            - LGPL-2.1
            - LGPL-3.0
            - BSD-2-Clause
            - BSD-3-Clause
            - MPL-2.0
            - proprietary
            - custom
            - public domain
        source_url:
          type: string
          format: uri
          pattern: ^https://
          description: URL to the source code repository of the compiler/interpreter
        is_reference:
          type: boolean
          description: Whether this is the reference implementation

  paradigms:
    type: array
    description: Primary programming paradigms supported by the language
    items:
      type: string
      enum:
        - imperative
        - procedural
        - declarative       # High-level specification (CSS, SQL)
        - functional        # General functional programming
        - purely functional # Strict functional purity (Haskell)
        - object-oriented   # Includes class-based and prototype-based
        - prototype-based   # JavaScriptâ€™s object system
        - event-driven      # JavaScript, GUI frameworks
        - logic             # Prolog
        - concurrent        # Rust, Go
        - generic           # C++, Rust templates
        - reflective        # Python, JavaScript
        - array-oriented    # APL, NumPy-style
        - stack-oriented    # Forth
        - dataflow          # LabVIEW (partially visual)
        - meta-programming  # Lisp, Rust macros
        - aspect-oriented   # AspectJ
        - agent-oriented    # Multi-agent systems
        - rule-based        # Expert systems, CLIPS
        - markup            # HTML
        - constraint        # Constraint programming (Prolog variants)
        - modular           # Modula-2, Ada
        - reactive          # Elm, RxJS
        - process-oriented  # Occam
        - concatenative     # Factor
        - parallel          # CUDA, OpenMP
        - total functional  # Total functional programming
        - literate          # Literate Haskell
        - language-oriented # Domain-specific language design
        - data-driven       # Data-driven design
        - natural-language  # Inform 7
        - symbolic          # Lisp, Prolog
        - query             # SQL, SPARQL
        - visual            # Scratch, LabVIEW
        - template-based    # C++ templates, PHP
        - structured
        - esoteric          # Brainfuck          
        - distributed

  typing:
    type: object
    description: type system characteristics
    properties:
      system:
        type: string
        description: core type system approach
        enum:
          - static
          - dynamic
          - gradual
          - dependent
          - linear
          - duck
          - untyped
      type_checking:
        type: string
        description: when type checking occurs
        enum:
          - compile-time
          - runtime
          - hybrid
      structural:
        type: boolean
        description: whether typing is structural (duck typing) or nominative (named types)
      strength:
        type: string
        description: level of type checking enforcement (rejection of invalid operations)
        enum:
          - strong  
          - weak    
          - mixed   
      inference:
        type: string
        description: whether types can be automatically inferred
        enum:
          - none    
          - partial 
          - full    
      type_coercion:
        type: string
        description: how aggressively the language converts between types
        enum:
          - none        
          - conservative 
          - moderate    
          - aggressive  
      type_annotations:
        type: string
        description: whether type annotations are required, optional, or not available
        enum:
          - none     
          - optional 
          - required 

  execution:
    type: object
    description: How code is executed and its performance characteristics
    properties:
      type:
        type: array
        description: Method of code execution
        items:
          type: string
          enum:
            - compiled
            - interpreted
            - interpreted with JIT compilation
            - hybrid
            - transpiled
            - parsed
            - query-optimized
      compiles_to:
        type: array
        description: Target formats when code is compiled
        items:
          type: string
          enum:
            - machine code
            - bytecode
            - WebAssembly
            - JavaScript
            - LLVM IR
            - C
            - assembly
            - GPU code
            - query plan
            - other intermediate representation
      runtime_environments:
        type: array
        description: Environments where the code can execute
        items:
          type: string
          enum:
            - language-specific runtime
            - JVM
            - BEAM VM
            - Ruby VM
            - Docker container
            - native OS process
            - browser
            - microcontroller
            - custom VM
            - native binary
            - cloud function environment
            - WebAssembly
            - embedded interpreter
            - serverless
            - CLR
      performance:
        type: object
        description: Performance characteristics
        properties:
          startup_time:
            $ref: "#/definitions/speed_scale"
            description: |
              Typical time for a minimal 'hello world' style application (CLI or simple server) to initialize and become responsive or complete its first task.
              * very fast: e.g., <10ms (typical for compiled native binaries)
              * fast: e.g., 10-50ms
              * moderate: e.g., 50-200ms (typical for lightweight JIT/VMs)
              * slow: e.g., 200ms-1s
              * very slow: e.g., >1s (typical for heavier runtimes or extensive initial JIT)
          memory_usage:
            $ref: "#/definitions/rating_scale"
            description: | 
              Typical resident set size (RSS) or working set for a simple, common task (e.g., 'hello world' web server under minimal load, basic data processing script) relative to other languages. Focus on baseline runtime and simple application overhead.
              * very low: Minimal overhead, comparable to C/Rust (e.g., <10MB for simple servers)
              * low: Efficient, small footprint (e.g., 10-50MB)
              * moderate: Average footprint for managed languages (e.g., 50-150MB)
              * high: Larger footprint, noticeable overhead (e.g., 150-300MB)
              * very high: Exceptionally large footprint (e.g., >300MB)
          computation_speed:
            $ref: "#/definitions/speed_scale"
            description: |
              Raw computation performance on CPU-bound tasks, often assessed using standardized benchmarks (e.g., The Computer Language Benchmarks Game).
              * very fast: Performance comparable to C, C++, Rust (e.g., within 0-2x slower)
              * fast: Significantly faster than average, but with a noticeable gap to the top tier (e.g., 2-5x slower than C)
              * moderate: Average for general-purpose languages, often including JIT-compiled languages (e.g., 5-15x slower than C)
              * slow: Typically interpreted languages or those with significant overhead (e.g., 15-50x slower than C)
              * very slow: Among the slowest for CPU-bound tasks (e.g., >50x slower than C)
          compilation_speed:
            $ref: "#/definitions/speed_scale"
            description: |
              Time taken to compile or build a medium-sized project (e.g., 10k-100k lines of code) from a clean state. For interpreted languages, this can refer to initial parsing/bytecode generation if significant. Consider both full and common incremental build scenarios.
              * very fast: e.g., incremental builds in <1s, full builds in seconds
              * fast: e.g., full builds in tens of seconds
              * moderate: e.g., full builds in 1-5 minutes
              * slow: e.g., full builds in 5-15 minutes
              * very slow: e.g., full builds taking >15 minutes

  domains:
    type: object
    description: Areas where the language is commonly used
    properties:
      primary:
        type: array
        description: Main use cases and strongest applications
        items:
          type: string
          enum:
            - web development
            - server-side applications
            - desktop applications
            - mobile development
            - systems programming
            - game development
            - scientific computing
            - data science
            - artificial intelligence
            - database management
            - network programming
            - browser extensions
            - compiler
            - interpreter
            - operating systems
            - real-time computing
            - cloud computing
            - blockchain
            - IoT
            - DevOps
            - edge computing
            - WebAssembly
            - distributed system
            - software build
            - build automation
            - user interface
            - microcontroller programming
            - 3D computer graphics
            - 2D computer graphics
            - spreadsheet
            - computer configuration
            - operational semantics
            - education
            - typesetting
            - conformance testing
            - statistics
            - numerical analysis
            - bioinformatics
            - data visualization
            - email filtering
            - shell
            - computer-aided design
            - computer numerical control
            - digital image processing
            - visual programming
            - computer font
            - publishing
            - interactive fiction
            - assembly
            - analysis
            - automated theorem proving
            - natural-language
            - intermediate representation
            - chemistry
            - geographic information system
            - physics
            - MUD
            - embedded systems
            - configuration management
            - computer-aided manufacturing
            - annotation
            - knowledge-based system
            - low code development
            - robotics
            - hypermedia
            - multi-agent system
            - formal verification
            - biology
            - music
            - scripting
            - video processing
            - audio processing
            - automation
            - workflow management
            - quantum programming
            - text processing
            - infrastructure as code
            - build management
            - data integration
            - image processing
            - animation
            - financial systems
            - simulation
            - virtual reality
            - augmented reality
            - machine learning frameworks
            - e-commerce
            - cryptocurrency
            - business applications
            - data processing
            - safety-critical systems
            - aerospace
            - telecommunications
            - system administration
            - high-performance computing
            - mathematics
            - microservices
            - testing
            - big data
            - templating
            - machine learning
      secondary:
        type: array
        description: Additional common but not primary use cases
        items:
          $ref: "#/properties/domains/properties/primary/items"
      emerging:
        type: array
        description: New or growing areas of application
        items:
          $ref: "#/properties/domains/properties/primary/items"

  platforms:
    type: object
    description: Supported execution environments and platforms
    properties:
      operating_systems:
        type: array
        description: Operating systems where the language can run
        items:
          type: string
          enum:
            - Windows
            - macOS
            - Linux
            - BSD
            - Unix
            - Solaris
            - Android
            - iOS
            - embedded
            - bare metal
            - DOS
      architectures:
        type: array
        description: CPU architectures supported
        items:
          type: string
          enum:
            - x86
            - x86-64
            - ARM
            - ARM64
            - RISC-V
            - MIPS
            - PowerPC
            - SPARC
            - SPARC64
            - IA-64
            - Alpha
            - AVR
            - GPU
            - WebAssembly
            - platform-independent
      cloud_function_environments:
        type: array
        description: Cloud platforms where the language can be deployed as a cloud function, if applicable
        items:
          type: string
          enum:
            - AWS Lambda
            - Google Cloud Functions
            - Azure Functions
            - Cloudflare Workers
            - Vercel Functions
            - Deno Deploy
            - DigitalOcean Functions
            - IBM Cloud Functions
            - Alibaba Function Compute
            - Oracle Cloud Functions
            - Netlify Functions
            - Heroku
            - Firebase Functions
            - Fastly Compute@Edge

  ecosystem:
    type: object
    description: Community and support infrastructure
    properties:
      maturity:
        $ref: "#/definitions/rating_scale"
        description: |
          Overall stability, proven track record, and predictability of the language specification, core tooling, and primary libraries.
          * very high: Decades of widespread production use, extremely stable APIs, robust tooling (e.g., Java, C).
          * high: Well-established (many years), stable core features, reliable ecosystem (e.g., Python, C#).
          * moderate: Gaining widespread adoption, core is largely stable, but some ecosystem components may still be evolving rapidly (e.g., Go, Rust in recent years).
          * low: Newer or more niche, core language may still see significant changes or refinements, ecosystem less established (e.g., Swift in its early years, Zig).
          * very low: Experimental, actively changing, APIs and tools are in flux, not yet widely proven for diverse production use.
      package_registry:
        type: string
        description: Main package/library repository URL or name
      community_size:
        $ref: "#/definitions/size_scale"
        description: |
          Estimated global number of active developers, contributors, and users. Based on metrics like GitHub activity, Stack Overflow questions/tags, package registry downloads, forum activity, and major conference attendance.
          * very large: Millions of active developers (e.g., JavaScript, Python)
          * large: Hundreds of thousands to over a million (e.g., Java, C#, C++)
          * medium: Tens of thousands to a few hundred thousand (e.g., Go, Ruby, Swift, Rust)
          * small: Thousands to tens of thousands (e.g., Elixir)
          * very small: Hundreds to a few thousand (e.g., Nim, Crystal)
      learning_resources:
        $ref: "#/definitions/size_scale"
        description: |
          Quantity and perceived quality of available learning materials, including official documentation, books, online courses, tutorials, community forums, and comprehensive example projects.
          * very large: Extensive, high-quality, and diverse resources for all skill levels across numerous platforms (e.g., Python, JavaScript)
          * large: Abundant good quality books, excellent official documentation, many online courses and active communities (e.g., Java, C#)
          * medium: Several well-regarded books, good official docs, a growing body of tutorials and community content (e.g., Go, Rust)
          * small: Limited selection of books, documentation may be good but less extensive in practical guides, fewer third-party tutorials (e.g., Scala, Elixir)
          * very small: Primarily relies on official documentation and a small number of community articles/blogs; sparse third-party resources (e.g., newer or very niche languages like Idris)
      job_market_demand:
        $ref: "#/definitions/rating_scale"
        description: |
          Relative level of employment opportunities and hiring demand, considering number of job postings, industry survey data, and general industry adoption trends.
          * very high: Consistently among the most in-demand languages globally across diverse sectors (e.g., Python, JavaScript, Java)
          * high: Strong and widespread demand, often a primary skill in many organizations (e.g., C#, C++, Go)
          * moderate: Healthy demand, often in specific niches or as a growing skill; good opportunities exist (e.g., Swift, Kotlin, Rust, Scala)
          * low: Limited demand, often for specialized roles, legacy systems, or in smaller markets (e.g., Ruby, Perl, Elixir)
          * very low: Niche, academic, or very new to the market with few dedicated job postings (e.g., Haskell, Clojure, F# outside specific domains)
  complexity:
    type: object
    description: Learning and usage difficulty metrics
    properties:
      learning_curve:
        $ref: "#/definitions/rating_scale"
        description: |
          Effort and time required for an experienced developer (proficient in at least one other common language) to reach a level of basic to intermediate productivity.
          * very low: Productive within days; simple syntax and core concepts (e.g., Python for scripting, Go for basic applications)
          * low: Productive within a few weeks; intuitive for those with prior experience (e.g., JavaScript, C# for common tasks)
          * moderate: Requires a month or more of focused effort; involves mastering a larger set of concepts or a different paradigm (e.g., Java and its ecosystem, Swift)
          * high: Steeper curve, potentially several months; involves complex or unique concepts (e.g., Rust's ownership, Scala's type system, Haskell's purity)
          * very high: Exceptionally challenging; requires deep understanding of abstract/complex concepts or a vast feature set from the outset (e.g., C++ for advanced usage, Ada)
      cognitive_load:
        $ref: "#/definitions/rating_scale"
        description: |
          Ongoing mental effort required to write, understand, debug, and maintain code, considering language verbosity, implicitness, number of core concepts to juggle, and complexity of state management.
          * very low: Minimal mental juggling; code is often explicit, simple, and predictable (e.g., Go)
          * low: Generally straightforward; common tasks can be done without deep thought about language intricacies (e.g., Python for many use cases)
          * moderate: Requires managing several interconnected concepts or being mindful of language-specific behaviors (e.g., C# with LINQ and async, JavaScript with its prototype chain and event loop)
          * high: Often requires deep concentration on language rules, type interactions, memory management, or concurrency models (e.g., Rust, Scala, C++)
          * very high: Consistently demands high mental effort due to extreme abstraction, density, or subtle interactions (e.g., advanced Haskell, APL, heavy C++ template metaprogramming)
      syntax_complexity:
        $ref: "#/definitions/rating_scale"
        description: |
          Perceived difficulty stemming from the language's grammar, number of keywords, use of symbols, syntactic sugar, and overall readability/parsability by humans.
          * very low: Minimalist, highly regular, and often described as 'clean' (e.g., Python, Go, Lisp dialects)
          * low: Generally intuitive with few surprising constructs for developers familiar with common language families
          * moderate: A fair number of keywords, operators, and syntactic constructs; some constructs may be less common or require more context (e.g., Java, C#, JavaScript)
          * high: Large grammar, many keywords/operators, potentially ambiguous constructs, or significant use of punctuation/symbols (e.g., C++, Perl, Scala)
          * very high: Extremely dense, symbol-heavy, highly unconventional, or context-sensitive grammar that is challenging for newcomers (e.g., APL, Forth)
      semantic_complexity:
        $ref: "#/definitions/rating_scale"
        description: |
          Difficulty arising from the meaning, interaction, and implications of language constructs, its type system, memory model, concurrency model, or core paradigms.
          * very low: Direct and simple semantics; behavior is highly predictable with few abstract concepts (e.g., early BASIC, simple scripting languages)
          * low: Core concepts are straightforward and behave as expected from common programming experience (e.g., Go, Python)
          * moderate: Involves more advanced or abstract concepts such as generics, complex inheritance/composition patterns, specific runtime behaviors, or moderately complex type systems (e.g., Java, C#)
          * high: Relies on deep, subtle, or highly abstract concepts like advanced type systems, manual memory management with intricate rules, powerful metaprogramming, or complex concurrency models (e.g., Rust, Haskell, Scala)
          * very high: Semantics are tied to highly abstract mathematical foundations or involve extremely complex interactions that require significant expertise to reason about (e.g., C++ template metaprogramming in depth, dependent types)

  language_features:
    type: object
    description: Core language capabilities and characteristics
    properties:
      immutability:
        type: string
        description: How the language handles immutable data
        enum:
          - none
          - optional
          - enforced
          - default
          - partial
      enums:
        type: string
        description: Level of enumeration type support
        enum:
          - none
          - basic
          - algebraic
          - bitfield
          - extensible
      metaprogramming:
        type: boolean
        description: Whether the language supports code that can modify/generate code
      generics:
        type: boolean
        description: Whether the language supports generic programming
      c_interop:
        type: boolean
        description: Whether the language has native C language interoperability
      pattern_matching:
        type: boolean
        description: Whether the language supports structural pattern matching
      null_safety:
        type: boolean
        description: Whether the language has built-in null reference protection
      memory_safety:
        type: object
        description: Memory safety characteristics
        properties:
          type:
            type: string
            description: Primary memory safety approach
            enum:
              - manual
              - managed
              - hybrid
              - unsafe
          level:
            $ref: "#/definitions/rating_scale"
            description: |
              The degree to which the language, by default and through its common idioms, prevents or mitigates memory errors like buffer overflows, use-after-free, and dangling pointers.
                * very high: Strong, often compile-time enforced guarantees against most memory errors without requiring manual intervention for safety (e.g., Rust's ownership and borrowing)
                * high: Primarily managed runtimes with automatic garbage collection that prevent most direct memory errors, though unsafe operations might be possible via specific escape hatches (e.g., Java, C#, Go, Python)
                * moderate: Offers mechanisms like ARC or smart pointers but still allows or requires significant programmer diligence to avoid memory errors, especially in performance-critical code (e.g., Swift, modern C++ used diligently)
                * low: Relies heavily on programmer discipline for memory safety; language provides raw memory access with few built-in safeguards (e.g., C, C++ used without modern safety practices)
                * very low: Essentially no built-in memory safety features beyond basic allocation/deallocation primitives; programmer is fully responsible (e.g., Assembly)
      memory_management:
        type: object
        description: Memory allocation and deallocation approach
        required:
          - type
        properties:
          type:
            type: string
            description: Primary memory management strategy
            enum:
              - manual
              - garbage collection
              - reference counting
              - hybrid
              - region-based
              - RAII
              - arena
              - stack-only
          implementation:
            type: string
            description: Specific implementation details of memory management
          manual_control:
            type: boolean
            description: Whether manual memory management control available
      key_features:
        type: array
        description: Distinctive language capabilities
        items:
          type: string
          enum:
            - first-class functions
            - closures
            - pattern matching
            - algebraic data types
            - type inference
            - operator overloading
            - multiple inheritance
            - mixins
            - traits/interfaces
            - zero-cost abstractions
            - hot reload
            - REPL
            - interactive development
            - native FFI
            - macros
            - async/await
            - channels
            - ownership system
            - type classes
            - extension methods
            - string interpolation
            - reflection
            - meta-programming
            - decorators/annotations
            - destructuring
            - range types
            - unified function call syntax
            - variadic functions
            - named arguments
            - prototypal inheritance
            - modules
            - iterators/generators
            - proxies
            - symbols
            - generics
            - semantic markup
            - accessibility attributes
            - lambdas
            - coroutines
            - tail-call optimization
            - contracts
            - templates
            - pure functions
            - monads
            - currying
            - lazy evaluation

  concurrency:
    type: object
    description: Parallel execution capabilities
    properties:
      model:
        type: string
        description: Primary approach to handling concurrent execution
        enum:
          - none
          - threads
          - event loop
          - actors
          - CSP
          - STM
          - goroutines
          - fibers
          - coroutines
          - fork-join
          - dataflow
          - parallel tasks
      features:
        type: array
        description: Specific concurrency mechanisms supported
        items:
          type: string
          enum:
            - async/await
            - promises/futures
            - channels
            - thread pools
            - work stealing
            - green threads
            - software transactional memory
            - message passing
            - shared memory
            - lock-free data structures
            - parallel collections
            - supervisors
            - distributed computing
            - task parallelism
            - data parallelism
            - concurrent data structures
            - atomic operations
            - actors
      ease_of_use:
        $ref: "#/definitions/rating_scale"
        description: |
          How easily and safely developers can write, debug, and reason about concurrent or parallel programs, considering built-in abstractions and protection against common issues.
          * very high: High-level, intrinsically safe, and easy-to-reason-about concurrency models are core to the language (e.g., Go's goroutines/channels, Erlang/Elixir's actors)
          * high: Well-designed language features and standard library support that significantly simplify common concurrent tasks and mitigate risks (e.g., C# async/await, Java's modern concurrency utilities, Swift actors)
          * moderate: Provides capable concurrency primitives, but requires careful design and deeper understanding to use safely and effectively; abstractions may be less comprehensive (e.g., Python's asyncio, Rust's async/await)
          * low: Basic primitives (e.g., threads, locks) are available but are difficult to use correctly and safely, prone to common concurrency errors without significant expertise (e.g., C/C++ with pthreads or std::thread directly)
          * very low: No built-in concurrency support, or mechanisms are extremely rudimentary, unsafe, or highly platform-dependent

  error_handling:
    type: object
    description: Error and exception management
    properties:
      primary_mechanism:
        type: string
        description: Main approach to handling errors
        enum:
          - exceptions
          - result types
          - error codes
          - conditions
          - optional types
          - monadic error handling
          - pattern matching
          - signals
          - assertions
          - other
      features:
        type: array
        description: Specific error handling capabilities
        items:
          type: string
          enum:
            - stack traces
            - error chaining
            - custom error types
            - recovery mechanisms
            - panic/catch
            - error context
            - error categories
            - error propagation
            - multiple error types
            - error formatting
            - cleanup actions
            - resource management
            - error logging
            - error reporting
            - error translation
            - graceful degradation
            - validation
            - fallback content
      stack_traces:
        type: boolean
        description: Whether the language supports execution stack traces
      debugging:
        type: object
        description: Debugging support features
        properties:
          source_maps:
            type: boolean
            description: Whether source mapping is supported
          breakpoints:
            type: boolean
            description: Whether breakpoint debugging is supported
          step_debugging:
            type: boolean
            description: Whether step-by-step debugging is supported

  package_managers:
    type: object
    description: Tools for dependency management
    properties:
      primary:
        type: string
        description: Main package manager for the language
      alternatives:
        type: array
        description: Other available package managers
        items:
          type: string

  popular_frameworks:
    type: object
    description: Widely used development frameworks
    properties:
      frontend:
        type: array
        description: UI/client-side frameworks
        items:
          type: string
      backend:
        type: array
        description: Server-side frameworks
        items:
          type: string
      testing:
        type: array
        description: Testing frameworks
        items:
          type: string
      mobile:
        type: array
        description: Mobile development frameworks
        items:
          type: string

  development_tools:
    type: object
    description: Development support tools
    properties:
      lsps:
        type: array
        description: Language Server Protocol implementations
        items:
          type: string
      debugging:
        type: array
        description: Debugging tools
        items:
          type: string
      profiling:
        type: array
        description: Performance analysis tools
        items:
          type: string
      build_systems:
        type: array
        description: Build automation tools distinct from package managers
        items:
          type: string
      linters:
        type: array
        description: Code quality tools
        items:
          type: string

  standard_library:
    type: object
    description: Built-in language capabilities
    properties:
      maturity:
        $ref: "#/definitions/rating_scale"
        description: |
          The perceived completeness, stability, API consistency, and quality of the language's standard library.
          * very high: Extensive, highly stable ("battle-tested"), well-documented, and consistently designed, covering a vast range of common tasks (e.g., Python, Java, .NET)
          * high: Comprehensive for most common needs, generally stable APIs, good quality and documentation (e.g., Go, Ruby)
          * moderate: Provides good coverage for core functionalities; some areas might still be evolving, or the API design might have some inconsistencies (e.g., Rust, Swift, C++ STL)
          * low: Intentionally lean, relying on third-party packages for many common tasks, or newer with less field testing (e.g., JavaScript (core ECMAScript for non-browser tasks), C)
          * very low: Very minimal, incomplete, highly unstable, or virtually non-existent, requiring external libraries for almost all non-trivial tasks
      key_areas:
        type: array
        description: Core functionality areas covered by standard library
        items:
          type: string
          enum:
            - file I/O
            - networking
            - concurrency
            - data structures
            - algorithms
            - text processing
            - cryptography
            - database access
            - HTTP client/server
            - JSON/XML processing
            - regular expressions
            - date/time
            - mathematics
            - compression
            - serialization
            - testing
            - logging
            - CLI tools
            - process management
            - security
            - accessibility
            - multimedia
            - web components
            - graphics
            - GUI
            - file system operations
            - internationalization
            - random number generation
      size:
        $ref: "#/definitions/size_scale"
        description: |
          The relative breadth and depth of modules, APIs, and functionalities included by default within the standard library.
          * very large: "Batteries-included" philosophy; offers extensive built-in functionality for a wide array of domains (e.g., Python, Java, .NET/C#)
          * large: Provides a substantial set of utilities and modules covering many common programming tasks beyond just core language support (e.g., Go, Ruby)
          * medium: Offers essential functionalities for common tasks, relying more on third-party libraries for specialized features (e.g., Rust, Swift, C++ STL)
          * small: Intentionally lean, focusing on core language features, minimal runtime dependencies, and fundamental utilities (e.g., C, JavaScript (core ECMAScript), Lua)
          * very small: Extremely minimalistic, providing only the bare essentials for language operation (e.g., Scheme, Forth)

  versioning:
    type: object
    description: Versioning and release information
    properties:
      release_cycle:
        type: string
        description: How releases are managed
        enum:
          - fixed schedule
          - feature-driven
          - long-term support
          - rolling release
          - time-based
          - semantic versioning
          - calendar versioning
          - rapid release
          - enterprise
          - living standard
      backwards_compatibility:
        $ref: "#/definitions/rating_scale"
        description: |
          The degree to which code written for older versions of the language and its standard library continues to compile and run correctly with newer versions, and the predictability of breaking changes.
          * very high: Extremely strong commitment; breaking changes are exceptionally rare, even across major versions over many years, often with formal guarantees (e.g., Go 1.x, Java)
          * high: Strong commitment; breaking changes are infrequent, well-documented, usually follow long deprecation cycles (e.g., C#, Python within major versions)
          * moderate: Generally good, but breaking changes can occur between major versions or occasionally in minor versions, requiring some code modification (e.g., Swift, JavaScript (language spec vs. evolving web APIs), Ruby)
          * low: Breaking changes are relatively common between versions, or major ecosystem shifts require significant migration effort (e.g., Scala 2 to 3, Python 2 to 3)
          * very low: Little to no guarantee of backwards compatibility; frequent and significant breaking changes are expected, typical of languages in early/experimental stages

  history:
    type: object
    description: Language origins and evolution
    properties:
      inception:
        type: string
        format: date
        description: Date when the language was initially created
      developer:
        type: array
        description: Organizations or teams that developed the language
        items:
          type: string
      designed_by:
        type: array
        description: Individuals who designed the language
        items:
          type: string
      described_by:
        type: string
        description: Official standard or specification for the language, if applicable
        nullable: true
      standards_bodies:
        type: array
        description: Organizations or bodies that standardized the language, if applicable
        items:
          type: string
      logo:
        type: string
        format: uri
        pattern: ^https://
        description: URL for the language logo, if available
      influenced_by:
        type: object
        description: Details of other languages and paradigms that influenced this language
        properties:
          languages:
            type: array
            items:
              type: string
            description: List of programming languages that influenced the development of this language
          paradigms:
            $ref: "#/properties/paradigms"
            description: Programming paradigms that influenced the design of this language

  official_website:
    type: string
    format: uri
    pattern: ^https://
    description: URL of the official website or homepage for the programming language, if available

  official_blog_rss:
    type: string
    format: uri
    pattern: ^https://
    description: URL of the official blog/devlog for the language, primarily where news of changes to the language is announced. Must be in either RSS or Atom format

  documentation:
    type: object
    description: Information about the language's documentation resources
    properties:
      quality:
        $ref: "#/definitions/rating_scale"
        description: |
          Overall quality of the official documentation, assessed on clarity, accuracy, completeness, organization, navigability, quality of examples, and how up-to-date it is.
          * very high: Exceptional in all aspects; widely praised. Includes comprehensive tutorials, API references, cookbooks, and conceptual explanations (e.g., Go, Rust, Python, MDN for Web APIs)
          * high: Comprehensive, clear, accurate, well-maintained, and easy to navigate. Covers most user needs effectively (e.g., C# (Microsoft Docs), Swift.org)
          * moderate: Generally good and covers most necessary topics but might have some gaps, occasional outdated sections, or minor issues with organization/clarity
          * low: Lacks sufficient detail in important areas, is frequently outdated, hard to navigate, or contains inaccuracies, often forcing reliance on unofficial resources
          * very low: Severely deficient, inaccurate, incomplete, or virtually non-existent, making it very difficult to learn or use the language effectively from official sources
      official_sources:
        type: array
        items:
          type: string
          format: uri
          pattern: ^https://
        description: URLs of official documentation sources for the language
      community_resources:
        type: array
        items:
          type: string
          format: uri
          pattern: ^https://
        description: URLs of community-contributed resources or guides for the language

  references:
    type: object
    description: External references for the language
    properties:
      github_topics:
        type: array
        description: GitHub topics for the language
        items:
          type: string
      quora_topics:
        type: array
        description: Quora topics for the language
        items:
          type: string
      stackexchange_tags:
        type: array
        description: Stack Exchange tags for the language
        items:
          type: string
      wikidata_id:
        type: string
        description: Wikidata ID for the language
      subreddit:
        type: string
        description: Subreddit for the language
      discord:
        type: string
        description: Discord server invite code or URL for the language community
      x_handle:
        type: string
        description: Official X handle for the language

  color:
    type: string
    pattern: ^#[A-Fa-f0-9]{6}$
    description: 'Official color of the language, in hexadecimal format #RRGGBB'
